import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import math
import random
import numpy as np
from sklearn.cluster import DBSCAN
from scipy.optimize import linear_sum_assignment
from scipy.optimize import minimize
import time

# 设置中文字体 (确保系统中有对应的字体)
try:
    plt.rcParams['font.sans-serif'] = ['WenQuanYi Micro Hei', 'SimHei', 'Arial Unicode MS', 'Microsoft YaHei', 'DejaVu Sans']
    plt.rcParams['axes.unicode_minus'] = False
except Exception as e:
    print(f"Warning: Could not set Chinese font. Error: {e}")
    print("Using default font. Chinese characters might not display correctly.")
    plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Arial']


class CarController:
    def __init__(self):
        # 小车运动参数
        self.x = 0.0
        self.y = 0.0
        self.theta = 0.0  # 车辆朝向角 (全向车位置更新不需要，但雷达扫描点的位置依赖于它)
        self.velocity = 0.0  # 速度标量
        # 全向车的速度可以表示为 (vx, vy)
        self.vx = 0.0
        self.vy = 0.0
        self.max_speed = 5.0  # 最大速度
        self.acceleration = 3.0  # 基础加速度 (用于手动控制，作为期望加速度的参考) - Note: MPC uses max_accel
        self.trajectory = []

        # *** 添加阻力参数 ***
        self.resistance_coeff = 0.8 # 阻力系数，值越大阻力越大 (与速度成正比，单位: s^-1)

        # MPC参数
        self.dt = 0.10  # MPC 采样时间 (Note: This is different from actual frame dt)
        self.prediction_horizon = 10  # 预测步数
        self.max_accel = 3.0  # 最大加速度 (m/s^2) - This is the maximum *control* acceleration MPC can command
        self.weight_goal = 10.0  # 目标点权重
        self.weight_velocity = 5.0  # 速度匹配权重（可选，让车倾向于达到一定速度，与手动方向相关）
        self.weight_accel = 0.1  # 加速度（控制量）权重
        self.weight_obstacle = 80.0  # 障碍物权重
        self.weight_boundary = 50.0  # 边界权重
        self.car_radius = 0.5  # 车辆半径 (用于碰撞和避障)

        # 调整的安全距离参数
        self.obstacle_visual_radius = 0.3  # 障碍物可视化/模型半径 (用于碰撞和避障)
        self.boundary_safe_distance = 1  # 边界安全距离
        self.avoidance_margin = 0.2 # MPC obstacle avoidance extra margin
        self.warning_zone_distance = 1.0 # Distance beyond safety_zone to start warning penalty

        self.world_size = 10  # 世界大小，正方形边长的一半

        # 避障/手动控制混合参数
        self.blend_safe_dist = self.car_radius + self.obstacle_visual_radius + self.avoidance_margin # 障安全区 + MPC裕量 (当障碍物距离 <= 此距离时，完全优先避障)
        self.manual_override_dist = self.blend_safe_dist + 3.0 # 离障碍物远于此距离时，完全优先目标/手动控制
        self.blend_alpha = 0.0 # 当前帧的混合比例 (1: 纯避障, 0: 纯目标/手动)


        # 雷达参数 (角度-距离传感器)
        self.radar_max_distance = 15.0  # 雷达最大探测距离
        self.radar_angle_res = 0.1  # 雷达角度分辨率 (度)
        self.radar_noise_std = 0.05  # 雷达距离测量噪声标准差
        self.raw_scan_data = []  # 存储 (angle_deg, distance) 列表

        # 障碍物跟踪和预测参数
        self.obstacle_clusters = []  # 存储 {id: int, center: (x, y), age: int} - Currently tracked
        self.obstacle_history = {}  # 存储 id: [pos1, pos2, ...]
        self.max_history_length = 10 # Store last 10 positions for velocity estimate
        self.max_expected_obstacle_speed = 1.0 # Used for tracking association threshold

        # DBSCAN 参数
        self.dbscan_eps = 0.5 # Max distance for neighbors
        self.dbscan_min_samples = 3 # Min points in a cluster


        # 初始化界面
        self.fig, self.ax = plt.subplots()
        self.fig.canvas.mpl_connect('key_press_event', self.on_key_press)
        self.fig.canvas.mpl_connect('key_release_event', self.on_key_release)
        self.fig.canvas.mpl_connect('button_press_event', self.on_mouse_click)  # 添加鼠标点击事件
        self.setup_plot()

        # 控制状态
        self.control_vector = np.array([0.0, 0.0])  # 手动控制输入方向矢量


        # 障碍物系统 (True Obstacles for Simulation)
        self.obstacles = []
        self.init_obstacles()

        # 图形对象
        self.car_circle = self.ax.add_patch(plt.Circle((self.x, self.y), self.car_radius, color='red', zorder=5))
        self.trajectory_line, = self.ax.plot([], [], 'b-', lw=1, alpha=0.7)
        self.info_text = self.ax.text(0.05, 0.95, '', transform=self.ax.transAxes, va='top', fontsize=10)
        self.scan_scatter = self.ax.scatter(np.empty(0), np.empty(0), c='lime', s=5, marker='.', alpha=0.5)
        self.border_rect = plt.Rectangle((-self.world_size, -self.world_size), 2 * self.world_size, 2 * self.world_size, linewidth=1,
                                         edgecolor='red', linestyle='--', facecolor='none', zorder=1)
        self.ax.add_patch(self.border_rect)
        self.mpc_trajectory_line, = self.ax.plot([], [], 'g--', lw=1.5, alpha=0.8)

        # 目标点
        self.goal = None
        self.goal_marker, = self.ax.plot([], [], 'rx', markersize=10, zorder=6)

        # 计时器用于控制更新频率
        self._last_time = time.time()

        # Use animation for smoother updates
        from matplotlib.animation import FuncAnimation
        # blit=False is simpler if artists are not tracked explicitly
        self.ani = FuncAnimation(self.fig, self.update_frame, frames=None, interval=30, blit=False, repeat=False)

        print(f"MPC blend parameters: safe_dist={self.blend_safe_dist:.2f}m, override_dist={self.manual_override_dist:.2f}m")
        print(f"Collision/MPC avoidance minimum distance: {self.car_radius + self.obstacle_visual_radius + self.avoidance_margin:.2f}m")
        print(f"Boundary safe distance: {self.boundary_safe_distance:.2f}m")
        print(f"Resistance coefficient: {self.resistance_coeff}")


    def setup_plot(self):
        """初始化绘图区域"""
        self.ax.set_title("全向自动驾驶小车 - 雷达(角度-距离) MPC避障与手动混合\nWASD: 移动  空格: 急停  鼠标点击: 设置目标点\n绿色虚线: MPC预测轨迹  橙色圆: 真实障碍物  绿点: 雷达点云", fontsize=10)
        self.ax.set_xlim(-self.world_size, self.world_size)
        self.ax.set_ylim(-self.world_size, self.world_size)
        self.ax.grid(True, alpha=0.3)
        self.ax.set_aspect('equal')
        plt.xlabel('X (m)')
        plt.ylabel('Y (m)')


    def on_key_press(self, event):
        """键盘按下事件"""
        if not hasattr(self, '_pressed_keys'):
            self._pressed_keys = set()
        self._pressed_keys.add(event.key)
        self.update_control_vector()

    def on_key_release(self, event):
        """键盘释放事件"""
        if hasattr(self, '_pressed_keys') and event.key in self._pressed_keys:
            self._pressed_keys.remove(event.key)
        self.update_control_vector()

    def update_control_vector(self):
        """更新控制方向矢量"""
        if not hasattr(self, '_pressed_keys'):
            self._pressed_keys = set()

        vec = np.array([0.0, 0.0])
        # Prioritize Space for stopping
        if ' ' in self._pressed_keys or 'space' in self._pressed_keys:
            self.vx = 0.0
            self.vy = 0.0
            self.velocity = 0.0
            self.control_vector = np.array([0.0, 0.0]) # Clear manual control direction
            # Remove space from set so we don't process other keys simultaneously (optional, but makes space a dedicated stop)
            self._pressed_keys.discard(' ')
            self._pressed_keys.discard('space')
            return

        if 'w' in self._pressed_keys or 'up' in self._pressed_keys:    vec += [0, 1]
        if 's' in self._pressed_keys or 'down' in self._pressed_keys:  vec += [0, -1]
        if 'a' in self._pressed_keys or 'left' in self._pressed_keys: vec += [-1, 0]
        if 'd' in self._pressed_keys or 'right' in self._pressed_keys: vec += [1, 0]

        # 归一化控制方向
        if np.linalg.norm(vec) > 0:
            self.control_vector = vec / np.linalg.norm(vec)
        else:
            self.control_vector = vec


    def on_mouse_click(self, event):
        """鼠标点击事件，设置目标点"""
        if event.inaxes == self.ax:
            self.goal = (event.xdata, event.ydata)
            self.goal_marker.set_data(self.goal[0], self.goal[1])  # 更新目标点标记
            print(f"目标点已设置为: {self.goal}")
            # 当设置新目标时，清除手动控制方向并停止车辆以便MPC接管
            if hasattr(self, '_pressed_keys'):
                self._pressed_keys = set()
            self.control_vector = np.array([0.0, 0.0])
            self.vx = 0.0 # Stop vehicle to clearly show MPC starting from rest towards new goal
            self.vy = 0.0
            self.velocity = 0.0


    def init_obstacles(self):
        """初始化6个动态障碍物 (真实的模拟对象)"""
        if hasattr(self, '_obstacle_patches'):
            for patch in self._obstacle_patches:
                patch.remove()
        self._obstacle_patches = []

        self.obstacles = []
        obstacle_id_counter = 0

        true_obstacle_radius = 0.4

        for i in range(6):
            speed = random.uniform(0.3, 0.6)

            if i < 3: # Circular motion
                motion_type = 'circle'
                angle = random.uniform(0, 2*math.pi)
                radius = random.uniform(4, 8)
                cx = radius * math.cos(angle)
                cy = radius * math.sin(angle)

                obstacle = {
                    'id': obstacle_id_counter,
                    'circle': plt.Circle((cx, cy), true_obstacle_radius, color='darkorange', alpha=0.8, zorder=3),
                    'motion_type': motion_type,
                    'speed': speed, # Angular speed (rad/s) - Let's use speed for linear component for simplicity consistent with linear type
                    'angle': angle, # Current angle
                    'radius': radius, # Radius of circular path
                    'true_radius': true_obstacle_radius # Store true radius
                }
                # Calculate linear speed for circular motion visualization consistency
                obstacle['linear_speed'] = speed * radius # m/s

                self.ax.add_patch(obstacle['circle'])
                self._obstacle_patches.append(obstacle['circle'])

            else: # Linear motion
                motion_type = 'linear'
                cx = random.uniform(-self.world_size + true_obstacle_radius, self.world_size - true_obstacle_radius)
                cy = random.uniform(-self.world_size + true_obstacle_radius, self.world_size - true_obstacle_radius)

                target_x = random.uniform(-self.world_size + true_obstacle_radius, self.world_size - true_obstacle_radius)
                target_y = random.uniform(-self.world_size + true_obstacle_radius, self.world_size - true_obstacle_radius)

                obstacle = {
                    'id': obstacle_id_counter,
                    'circle': plt.Circle((cx, cy), true_obstacle_radius, color='darkorange', alpha=0.8, zorder=3),
                    'motion_type': motion_type,
                    'speed': speed, # Speed of linear movement (m/s)
                    'target_pos': (target_x, target_y),
                    'true_radius': true_obstacle_radius
                }
                self.ax.add_patch(obstacle['circle'])
                self._obstacle_patches.append(obstacle['circle'])

            self.obstacles.append(obstacle)
            obstacle_id_counter += 1

        print(f"Initialized {len(self.obstacles)} simulation obstacles.")


    def ray_intersect_circle(self, origin, theta_rad, circle_center_pos, circle_radius):
        """射线与圆求交。返回交点在射线上的参数 t (距离)，如果无交点或交点在射线反方向则返回None。"""
        dx, dy = math.cos(theta_rad), math.sin(theta_rad)
        cx, cy = circle_center_pos
        ox, oy = origin

        fx = ox - cx
        fy = oy - cy
        r = circle_radius

        A = dx*dx + dy*dy
        B = 2 * (fx * dx + fy * dy)
        C = fx * fx + fy * fy - r * r

        delta = B * B - 4 * A * C

        if delta < 0:
            return None

        sqrt_delta = math.sqrt(delta)

        if abs(A) < 1e-9: return None

        t1 = (-B - sqrt_delta) / (2 * A)
        t2 = (-B + sqrt_delta) / (2 * A)

        positive_ts = [t for t in [t1, t2] if t >= -1e-9]

        if not positive_ts:
            return None

        min_t = min(positive_ts)

        # Add a small tolerance to avoid detecting collision point as inside/at origin
        # if min_t < 1e-6: return None # This check might be too aggressive, let's trust the math for t>=0


        return min_t


    def scan_environment(self):
        """模拟角度-距离雷达扫描环境。返回(角度(度), 距离)的列表。"""
        self.raw_scan_data = []
        origin = (self.x, self.y)

        car_orientation_rad = math.radians(self.theta)

        for angle_deg_relative in np.arange(0, 360, self.radar_angle_res):
            angle_rad_world = car_orientation_rad + math.radians(angle_deg_relative)

            closest_dist = self.radar_max_distance
            hit_found = False

            # 寻找这条射线与所有真实障碍物的最近交点距离
            for obstacle in self.obstacles:
                t = self.ray_intersect_circle(origin, angle_rad_world, obstacle['circle'].center, obstacle['true_radius']) # Use true radius

                if t is not None and t < closest_dist:
                    closest_dist = t
                    hit_found = True

            # If found a hit, record noisy distance measurement
            if hit_found:
                noisy_dist = closest_dist + random.gauss(0, self.radar_noise_std)
                noisy_dist = max(0.1, noisy_dist)
                noisy_dist = min(noisy_dist, self.radar_max_distance + self.radar_noise_std * 3)
                self.raw_scan_data.append((angle_deg_relative, noisy_dist))


    def convert_polar_to_cartesian(self, angle_deg_relative, distance, car_x, car_y, car_theta_deg):
        """将相对于小车的极坐标点 (角度(度), 距离) 转换为世界坐标系的 (x, y)。"""
        car_theta_rad = math.radians(car_theta_deg)
        angle_rad_relative = math.radians(angle_deg_relative)

        angle_rad_world = car_theta_rad + angle_rad_relative

        world_x = car_x + distance * math.cos(angle_rad_world)
        world_y = car_y + distance * math.sin(angle_rad_world)
        return (world_x, world_y)


    def cluster_scan_points(self):
        """将原始雷达数据 (角度, 距离) 转换为世界坐标 (x, y) 点，并进行聚类。"""
        if not self.raw_scan_data:
            self.scan_points_for_plot = np.empty((0, 2))
            return []

        world_scan_points = [
            self.convert_polar_to_cartesian(angle, dist, self.x, self.y, self.theta)
            for angle, dist in self.raw_scan_data
            if dist <= self.radar_max_distance + self.radar_noise_std * 3
        ]
        self.scan_points_for_plot = np.array(world_scan_points)

        if self.scan_points_for_plot.shape[0] < self.dbscan_min_samples:
            return []

        dbscan = DBSCAN(eps=self.dbscan_eps, min_samples=self.dbscan_min_samples)
        clusters = dbscan.fit_predict(self.scan_points_for_plot)

        clustered_points_map = {}
        for i, label in enumerate(clusters):
            if label != -1:
                if label not in clustered_points_map:
                    clustered_points_map[label] = []
                clustered_points_map[label].append(self.scan_points_for_plot[i])

        obstacle_centers = []
        for label, points in clustered_points_map.items():
            center = np.mean(points, axis=0)
            obstacle_centers.append(center)

        return obstacle_centers


    def track_obstacles(self, current_obstacle_centers, dt):
        """跟踪障碍物，并更新历史位置。使用匈牙利算法匹配当前检测到的中心与已知障碍物。"""
        if not current_obstacle_centers:
            new_obstacle_clusters = []
            for cluster in self.obstacle_clusters:
                cluster.setdefault('age', 0)
                cluster['age'] += 1
                if cluster['age'] < 5:
                    new_obstacle_clusters.append(cluster)
                else:
                    if cluster['id'] in self.obstacle_history:
                        del self.obstacle_history[cluster['id']]
            self.obstacle_clusters = new_obstacle_clusters
            return

        if not self.obstacle_clusters:
            for center in current_obstacle_centers:
                existing_ids = list(self.obstacle_history.keys())
                new_id = max(existing_ids + [-1]) + 1 if existing_ids else 0
                new_cluster = {'id': new_id, 'center': center, 'age': 0}
                self.obstacle_clusters.append(new_cluster)
                self.obstacle_history[new_id] = [center]
            return

        num_tracked = len(self.obstacle_clusters)
        num_detected = len(current_obstacle_centers)
        cost_matrix = np.full((num_tracked, num_detected), np.inf)

        # Threshold calculation: Max distance an object *could* move based on max speed + clustering noise + margin
        max_possible_movement = self.max_expected_obstacle_speed * dt # Use actual frame dt for tracking threshold
        match_threshold = max_possible_movement + self.obstacle_visual_radius * 2 + 0.5 # Added fixed margin for robustness

        for i in range(num_tracked):
            for j in range(num_detected):
                dist = np.linalg.norm(self.obstacle_clusters[i]['center'] - current_obstacle_centers[j])
                if dist < match_threshold:
                    cost_matrix[i, j] = dist

        try:
            row_ind, col_ind = linear_sum_assignment(cost_matrix)
        except ValueError as e:
            print(f"Warning: Cost matrix infeasible in track_obstacles: {e}. Aging existing tracks.")
            for cluster in self.obstacle_clusters:
                cluster.setdefault('age', 0)
                cluster['age'] += 1
            new_obstacle_clusters = [c for c in self.obstacle_clusters if c['age'] < 5]
            removed_ids = {c['id'] for c in self.obstacle_clusters if c not in new_obstacle_clusters}
            for obj_id in removed_ids:
                if obj_id in self.obstacle_history:
                    del self.obstacle_history[obj_id]
            self.obstacle_clusters = new_obstacle_clusters
            return

        updated_clusters = []
        matched_detected_indices = set(col_ind)
        matched_tracked_indices = set(row_ind)

        for i, j in zip(row_ind, col_ind):
            if cost_matrix[i, j] < np.inf:
                tracked_cluster = self.obstacle_clusters[i]
                detected_center = current_obstacle_centers[j]

                tracked_cluster['center'] = detected_center
                tracked_cluster['age'] = 0

                obstacle_id = tracked_cluster['id']
                if obstacle_id not in self.obstacle_history:
                    self.obstacle_history[obstacle_id] = []
                self.obstacle_history[obstacle_id].append(detected_center)
                if len(self.obstacle_history[obstacle_id]) > self.max_history_length:
                    self.obstacle_history[obstacle_id].pop(0)
                updated_clusters.append(tracked_cluster)

        for j in range(num_detected):
            if j not in matched_detected_indices:
                new_center = current_obstacle_centers[j]
                existing_ids = list(self.obstacle_history.keys())
                new_id = max(existing_ids + [-1]) + 1 if existing_ids else 0
                new_cluster = {'id': new_id, 'center': new_center, 'age': 0}
                updated_clusters.append(new_cluster)
                self.obstacle_history[new_id] = [new_center]

        for i in range(num_tracked):
            if i not in matched_tracked_indices:
                lost_cluster = self.obstacle_clusters[i]
                lost_cluster.setdefault('age', 0)
                lost_cluster['age'] += 1
                if lost_cluster['age'] < 5:
                    updated_clusters.append(lost_cluster)
                else:
                    if lost_cluster['id'] in self.obstacle_history:
                        del self.obstacle_history[lost_cluster['id']]

        self.obstacle_clusters = updated_clusters


    def predict_obstacle_positions(self):
        """根据历史位置预测障碍物在MPC预测步数后的位置。"""
        predicted_positions = []

        for cluster in self.obstacle_clusters:
            obstacle_id = cluster['id']
            if obstacle_id in self.obstacle_history and len(self.obstacle_history[obstacle_id]) >= 2:
                history = self.obstacle_history[obstacle_id]
                pos_current = history[-1]
                pos_prev = history[-2]

                # Velocity estimate using the last two points
                # We don't have exact time stamps for history points, assume average frame dt or MPC dt
                # Using MPC dt for consistency with prediction horizon calculation
                time_diff_approx = self.dt

                if time_diff_approx > 1e-6:
                    velocity_estimate = (pos_current - pos_prev) / time_diff_approx
                else:
                    velocity_estimate = np.array([0.0, 0.0])

                current_est_speed = np.linalg.norm(velocity_estimate)
                if current_est_speed > self.max_expected_obstacle_speed:
                    # Avoid division by zero if speed is zero
                    if current_est_speed > 1e-9:
                        velocity_estimate = (velocity_estimate / current_est_speed) * self.max_expected_obstacle_speed
                    else:
                        velocity_estimate = np.array([0.0, 0.0]) # Already zero

                # Predict future position over the MPC horizon (N steps of MPC dt)
                predicted_pos = pos_current + velocity_estimate * (self.prediction_horizon * self.dt)
                predicted_positions.append(predicted_pos)
            else:
                # Assume stationary if history is insufficient
                predicted_positions.append(cluster['center'])

        return predicted_positions


    def motion_model(self, state, control, dt):
        """车辆运动模型：state = [x, y, vx, vy]. control = [ax_control, ay_control].
           包含基于当前速度的阻力项。
        """
        # state = [x, y, vx, vy]
        # control = [ax_control, ay_control] - This is the *control* acceleration from the optimizer

        x, y, vx, vy = state
        ax_control, ay_control = control

        # *** 计算阻力加速度 ***
        # Resistance force is proportional to velocity and opposite direction: F_res = -k * v
        # Resistance acceleration is F_res / mass. Assuming mass = 1 or k incorporates mass: a_res = -resistance_coeff * v
        ax_resistance = -self.resistance_coeff * vx
        ay_resistance = -self.resistance_coeff * vy

        # *** 计算净加速度 ***
        net_ax = ax_control + ax_resistance
        net_ay = ay_control + ay_resistance

        # Update velocity using net acceleration
        next_vx = vx + net_ax * dt
        next_vy = vy + net_ay * dt

        # Apply speed limit *after* acceleration integration
        current_speed_sq = next_vx**2 + next_vy**2
        max_speed_sq = self.max_speed**2
        if current_speed_sq > max_speed_sq:
            # Avoid division by zero if speed is near zero
            if current_speed_sq > 1e-9:
                scale = self.max_speed / math.sqrt(current_speed_sq)
                next_vx *= scale
                next_vy *= scale
            else:
                # Speed is zero, no scaling needed
                next_vx = 0.0
                next_vy = 0.0


        # Update position using the new (potentially limited) velocity
        next_x = x + next_vx * dt
        next_y = y + next_vy * dt

        return np.array([next_x, next_y, next_vx, next_vy])


    def calculate_blend_ratio(self, dist_to_nearest_obstacle):
        """Calculates blend ratio (alpha) between avoidance (1) and manual (0)."""
        if dist_to_nearest_obstacle is None or dist_to_nearest_obstacle >= self.manual_override_dist:
            return 0.0
        if dist_to_nearest_obstacle <= self.blend_safe_dist:
            return 1.0

        range_dist = self.manual_override_dist - self.blend_safe_dist
        if range_dist <= 1e-9:
            return 1.0 if dist_to_nearest_obstacle <= self.blend_safe_dist else 0.0

        clamped_dist = np.clip(dist_to_nearest_obstacle, self.blend_safe_dist, self.manual_override_dist)
        alpha = (self.manual_override_dist - clamped_dist) / range_dist

        return np.clip(alpha, 0.0, 1.0)


    def mpc_cost(self, u_flat, x0, goal, predicted_obstacles):
        """MPC 优化目标函数。u_flat是展平的控制输入 [ax0, ay0, ax1, ay1, ...]."""
        # u_flat: Control sequence [ax0, ay0, ax1, ay1, ...] from the optimizer (represents *control* acceleration, not net)
        # x0: initial state [x, y, vx, vy]
        # goal: target position [gx, gy] (numpy array or None)
        # predicted_obstacles: list of predicted obstacle positions [ox, oy] (numpy arrays) at the end of the horizon
        # blend_alpha: Current blend ratio calculated in update_frame (1=avoidance, 0=manual/goal) - Accessed via self.blend_alpha

        cost = 0.0
        state = np.array(x0) # Start from current state

        mpc_predicted_path = [state[:2].tolist()]

        alpha = self.blend_alpha # Get the current blend ratio

        # Adjusted weights based on blend_alpha
        obstacle_cost_weight_scaled = alpha * self.weight_obstacle
        # Goal/Manual weight scaling should be inverse of obstacle scaling for blending
        # We use (1-alpha) scaling for the goal/manual component
        goal_or_manual_weight_scaled = (1.0 - alpha)


        for i in range(self.prediction_horizon):
            # Extract *control* acceleration for this step [ax_i, ay_i] from the optimizer's output
            # This is the acceleration the optimizer *commands*, before resistance is applied
            if (i * 2 + 1) >= len(u_flat):
                # print(f"Warning: u_flat index out of bounds at step {i}. Expected length {self.prediction_horizon*2}, got {len(u_flat)}.")
                break

            control_i = np.array([u_flat[i * 2], u_flat[i * 2 + 1]])

            # Predict next state using the motion model, which *includes* resistance
            # The motion model takes the *control* input [ax_i, ay_i] and the current state [x, y, vx, vy]
            # and calculates the next state considering *both* control and resistance.
            state = self.motion_model(state, control_i, self.dt)
            x, y, vx, vy = state

            mpc_predicted_path.append(state[:2].tolist())

            # --- Cost Calculation ---

            # 1. Goal/Manual Cost (Weighted by 1-alpha)
            goal_or_manual_cost_step = 0.0
            if goal is not None:
                dist_to_goal = np.linalg.norm(state[:2] - goal)
                # Apply (1-alpha) scaling to the base goal weight
                goal_or_manual_cost_step += goal_or_manual_weight_scaled * self.weight_goal * dist_to_goal**2
            else:
                # Penalize deviation from desired manual velocity (weighted by 1-alpha)
                desired_velocity = self.control_vector * self.max_speed
                velocity_error_sq = np.sum((state[2:] - desired_velocity)**2)
                # Apply (1-alpha) scaling to the base velocity weight
                goal_or_manual_cost_step += goal_or_manual_weight_scaled * self.weight_velocity * velocity_error_sq

            cost += goal_or_manual_cost_step

            # 2. Control Effort Cost (Standard weight)
            # Penalize the *control* acceleration commanded by the optimizer
            cost += self.weight_accel * np.sum(control_i**2)

            # 3. Obstacle Cost (Weighted by alpha)
            obstacle_cost_step = 0.0
            if obstacle_cost_weight_scaled > 1e-9 and predicted_obstacles:
                safe_distance = self.car_radius + self.obstacle_visual_radius + self.avoidance_margin
                warning_zone = safe_distance + self.warning_zone_distance

                for obs_pos in predicted_obstacles:
                    dist_to_obstacle = np.linalg.norm(state[:2] - obs_pos)
                    if dist_to_obstacle < safe_distance:
                        penetration = safe_distance - dist_to_obstacle
                        obstacle_cost_step += penetration**2
                    elif dist_to_obstacle < warning_zone:
                        smoothness_factor = 0.5
                        obstacle_cost_step += math.exp(-(dist_to_obstacle - safe_distance)/smoothness_factor)

                # Apply the scaled obstacle weight
                cost += obstacle_cost_weight_scaled * obstacle_cost_step

            # 4. Boundary Cost (Standard weight)
            boundary_cost_step = 0.0
            dist_left = state[0] - (-self.world_size)
            dist_right = self.world_size - state[0]
            dist_bottom = state[1] - (-self.world_size)
            dist_top = self.world_size - state[1]

            boundary_safe_distance = self.boundary_safe_distance

            if dist_left < boundary_safe_distance:
                boundary_cost_step += (boundary_safe_distance - dist_left)**2
            if dist_right < boundary_safe_distance:
                boundary_cost_step += (boundary_safe_distance - dist_right)**2
            if dist_bottom < boundary_safe_distance:
                boundary_cost_step += (boundary_safe_distance - dist_bottom)**2
            if dist_top < boundary_safe_distance:
                boundary_cost_step += (boundary_safe_distance - dist_top)**2

            cost += self.weight_boundary * boundary_cost_step

        self.mpc_trajectory = mpc_predicted_path

        return cost


    def solve_mpc(self, x0, goal, predicted_obstacles):
        """求解 MPC 控制序列。"""
        effective_goal = np.array(goal) if goal is not None else None
        u0 = np.zeros(self.prediction_horizon * 2)
        bounds = [(-self.max_accel, self.max_accel), (-self.max_accel, self.max_accel)] * self.prediction_horizon

        objective = lambda u_flat: self.mpc_cost(u_flat, x0, effective_goal, predicted_obstacles)

        # Using 'bounds' implies the control [ax, ay] is constrained directly.
        # The resistance is a separate force based on state (velocity).
        result = minimize(objective, u0,
                          method='SLSQP', bounds=bounds,
                          options={'maxiter': 50, 'ftol': 1e-2, 'disp': False})

        # mpc_cost already calculated and stored self.mpc_trajectory based on result.x

        if result.success:
            return result.x
        else:
            # print("MPC Optimization failed:", result.message)
            self.mpc_trajectory = [] # Clear potentially bad prediction trajectory
            return np.zeros(self.prediction_horizon * 2)


    def update_movement(self, dt):
        """使用MPC求解得到的控制量更新车辆状态。"""
        # dt: actual time passed since last frame

        current_state = np.array([self.x, self.y, self.vx, self.vy])
        predicted_obstacle_positions = getattr(self, 'predicted_obstacle_positions_for_mpc', [])

        # solve_mpc calculates the optimal *control* acceleration [ax, ay] for each step
        # and also sets self.mpc_trajectory based on the predicted states resulting from these *control* inputs
        # combined with resistance in the motion model.
        u_flat = self.solve_mpc(current_state, self.goal, predicted_obstacle_positions)

        # Apply the first control command [ax0, ay0] from the optimized sequence
        # This is the *commanded* acceleration, NOT the net acceleration
        if u_flat is not None and len(u_flat) >= 2:
            commanded_ax = u_flat[0]
            commanded_ay = u_flat[1]

            # *** Calculate resistance acceleration based on *current* velocity ***
            resistance_ax = -self.resistance_coeff * self.vx
            resistance_ay = -self.resistance_coeff * self.vy

            # *** Calculate the net acceleration applied to the vehicle ***
            net_ax = commanded_ax + resistance_ax
            net_ay = commanded_ay + resistance_ay


            # Update velocity based on net acceleration and actual frame dt
            self.vx += net_ax * dt
            self.vy += net_ay * dt

            # Apply speed limit *after* net acceleration integration
            current_speed = math.hypot(self.vx, self.vy)
            if current_speed > self.max_speed:
                if current_speed > 1e-9:
                    scale = self.max_speed / current_speed
                    self.vx *= scale
                    self.vy *= scale
                else:
                    self.vx = 0.0
                    self.vy = 0.0 # Avoid potential NaNs if scale was inf/nan


            self.velocity = math.hypot(self.vx, self.vy) # Update scalar velocity display

            # Update position based on the new velocity
            self.x += self.vx * dt
            self.y += self.vy * dt

            # Store current position for trajectory
            self.trajectory.append((self.x, self.y))
            max_trajectory_length = 500
            if len(self.trajectory) > max_trajectory_length:
                self.trajectory.pop(0)

        else:
            # If optimization failed and returned zeros or None, just apply resistance.
            # This effectively causes the vehicle to slow down.
            resistance_ax = -self.resistance_coeff * self.vx
            resistance_ay = -self.resistance_coeff * self.vy

            self.vx += resistance_ax * dt
            self.vy += resistance_ay * dt

            # Apply speed limit even when only resistance is applied
            current_speed = math.hypot(self.vx, self.vy)
            if current_speed > self.max_speed: # Should not happen if speed was within limit, but as safeguard
                if current_speed > 1e-9:
                    scale = self.max_speed / current_speed
                    self.vx *= scale
                    self.vy *= scale
                else:
                    self.vx = 0.0
                    self.vy = 0.0


            self.velocity = math.hypot(self.vx, self.vy)

            # Add position to trajectory even when stopping
            self.trajectory.append((self.x, self.y))
            max_trajectory_length = 500
            if len(self.trajectory) > max_trajectory_length:
                self.trajectory.pop(0)

            # Clear MPC trajectory if optimization failed
            self.mpc_trajectory = [] # This is already handled inside solve_mpc on failure


    def check_collision(self, obstacle_positions):
        """碰撞检测：检查小车是否与提供的障碍物位置列表发生碰撞。"""
        # Check against true obstacles for simulation realism.
        car_pos = np.array([self.x, self.y])
        for obstacle in self.obstacles:
            obs_pos = np.array(obstacle['circle'].center)
            obs_radius = obstacle['true_radius'] # Use the true radius
            collision_distance_sq = (self.car_radius + obs_radius)**2
            dist_sq = np.sum((car_pos - obs_pos)**2)
            if dist_sq < collision_distance_sq:
                return True
        return False


    def update_frame(self, frame=None):
        """主更新循环"""
        current_time = time.time()
        dt = max(0.001, current_time - self._last_time)
        self._last_time = current_time

        dt = min(dt, 0.1) # Clamp max dt


        # --- Simulation Updates ---

        # Update true obstacle positions (for simulating the world)
        for obstacle in self.obstacles:
            if obstacle['motion_type'] == 'circle':
                # Calculate linear distance moved along the circle circumference in dt
                # Assuming 'speed' is linear speed along circumference for consistency
                circumference = 2 * math.pi * obstacle['radius']
                if circumference > 1e-9: # Avoid division by zero if radius is zero
                    angle_moved = (obstacle['speed'] * dt) / obstacle['radius'] # delta angle = linear_dist / radius
                    obstacle['angle'] = (obstacle['angle'] + angle_moved) % (2 * math.pi)
                # If radius is zero, it's a point obstacle, assume stationary or handle differently.
                # For now, if radius is zero, angle_moved will be inf or NaN, motion won't update, which is fine.
                cx = obstacle['radius'] * math.cos(obstacle['angle'])
                cy = obstacle['radius'] * math.sin(obstacle['angle'])
                obstacle['circle'].center = (cx, cy)

            elif obstacle['motion_type'] == 'linear':
                target = np.array(obstacle['target_pos'])
                current = np.array(obstacle['circle'].center)
                direction = target - current
                dist_to_target = np.linalg.norm(direction)

                movement_this_step = obstacle['speed'] * dt

                if dist_to_target < max(movement_this_step * 0.5, 0.05):
                    cx, cy = target
                    obs_radius = obstacle['true_radius']
                    new_target_x = random.uniform(-self.world_size + obs_radius, self.world_size - obs_radius)
                    new_target_y = random.uniform(-self.world_size + obs_radius, self.world_size - obs_radius)
                    obstacle['target_pos'] = (new_target_x, new_target_y)
                    obstacle['circle'].center = (cx, cy)
                else:
                    if dist_to_target > 1e-9:
                        move_vec = direction / dist_to_target * movement_this_step
                        cx, cy = current + move_vec
                        obstacle['circle'].center = (cx, cy)
                    pass


        # --- Perception and Tracking ---
        self.scan_environment()
        current_obstacle_centers_world = self.cluster_scan_points()
        self.track_obstacles(current_obstacle_centers_world, dt) # Pass actual frame dt
        self.predicted_obstacle_positions_for_mpc = self.predict_obstacle_positions()


        # --- Blend Calculation ---
        car_pos_np = np.array([self.x, self.y])
        d_min = float('inf')
        if self.obstacle_clusters:
            current_tracked_centers = [c['center'] for c in self.obstacle_clusters]
            if current_tracked_centers:
                distances = [np.linalg.norm(car_pos_np - center) for center in current_tracked_centers]
                d_min = min(distances)
            else:
                d_min = float('inf')
        else:
            d_min = float('inf')

        self.blend_alpha = self.calculate_blend_ratio(d_min)


        # --- Control and Movement ---
        self.update_movement(dt) # Pass actual frame dt


        # --- Collision Check ---
        if self.check_collision(None):
            self.vx = 0.0
            self.vy = 0.0
            self.velocity = 0.0
            self.info_text.set_text("! 碰撞 ! 速度已重置")
            self.goal = None
            self.goal_marker.set_data([], [])
            print("Collision detected! Vehicle stopped.")

        else:
            info_str = f"速度: {self.velocity:.1f} m/s (vx:{self.vx:.1f}, vy:{self.vy:.1f})\n" \
                       f"手动方向: ({self.control_vector[0]:.1f}, {self.control_vector[1]:.1f})\n" \
                       f"最近障碍物: {d_min:.2f} m, MPC混合比例(避障/总): {self.blend_alpha:.2f}"

            if self.goal:
                car_pos_np = np.array([self.x, self.y])
                goal_pos_np = np.array(self.goal)
                dist_to_goal = np.linalg.norm(car_pos_np - goal_pos_np)
                info_str += f"\n目标点: ({self.goal[0]:.1f}, {self.goal[1]:.1f}) 距离: {dist_to_goal:.1f} m"
                if dist_to_goal < self.car_radius + 0.3:
                    self.vx = 0.0
                    self.vy = 0.0
                    self.velocity = 0.0
                    self.goal = None
                    self.goal_marker.set_data([], [])
                    info_str += "\n目标达成!"
                    print("Goal reached! Vehicle stopped.")

            self.info_text.set_text(info_str)


        # --- Graphics Updates ---
        self.car_circle.center = (self.x, self.y)

        if hasattr(self, 'scan_points_for_plot') and isinstance(self.scan_points_for_plot, np.ndarray) and self.scan_points_for_plot.ndim == 2 and self.scan_points_for_plot.shape[1] == 2:
            self.scan_scatter.set_offsets(self.scan_points_for_plot)
        else:
            self.scan_scatter.set_offsets(np.empty((0, 2)))

        if self.trajectory:
            traj_np = np.array(self.trajectory)
            self.trajectory_line.set_data(traj_np[:, 0], traj_np[:, 1])
        else:
            self.trajectory_line.set_data([], [])

        if hasattr(self, 'mpc_trajectory') and self.mpc_trajectory:
            if len(self.mpc_trajectory) > 0:
                mpc_traj_np = np.array(self.mpc_trajectory)
                self.mpc_trajectory_line.set_data(mpc_traj_np[:, 0], mpc_traj_np[:, 1])
            else:
                self.mpc_trajectory_line.set_data([], [])
        else:
            self.mpc_trajectory_line.set_data([], [])

        self.fig.canvas.draw_idle()


    def show(self):
        """显示matplotlib窗口并启动动画"""
        plt.show()

# 运行系统
if __name__ == "__main__":
    controller = CarController()
    controller.show()
